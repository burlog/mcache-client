/**

\mainpage Klient pro memcached server

\section quick V rychlosti

\subsection quick-ipc Multiprocesové prostředí

Příklad použití libmcache v multiprocesovém prostředí (např. MetaServer):

\code

#include <iostream>
#include <vector>
#include <string>

#include <mcache/mcache.h>

int main(int, char *[]) {
    // příprava seznamu adres serverů
    std::vector<std::string> servers;
    servers.push_back("memcache1:11211");
    servers.push_back("memcache2:11211");
    servers.push_back("memcache3:11211");
    servers.push_back("memcache4:11211");

    // vytvoření klienta (po childInit)
    mc::server_proxy_config_t scfg;
    scfg.io_opts.timeouts.connect = 3000;
    scfg.io_opts.timeouts.write = 3000;
    scfg.io_opts.timeouts.read = 3000;
    mc::ipc::client_t client(servers, scfg);

    // použití
    client.set("szn", "http://seznam.cz/");
    std::cout << client.get("szn").data << std::endl;
}

\endcode

Tento kód vám připraví k používání pool memcache serverů s konzistetním
hashováním a persistetním spojením na každý memcache server, které se zavírá po
první io chybě. Pro komunikaci se bude používat binární protokol, který memcache
podporuje od verze 1.3.

\subsection quick-thread Multithreadové prostředí

Příklad použití libmcache v multithreadovém prostředí (např. MTD):

\code

#include <iostream>
#include <vector>
#include <string>

#include <mcache/mcache.h>

int main(int, char *[]) {
    // příprava seznamu adres serverů
    std::vector<std::string> servers;
    servers.push_back("memcache1:11211");
    servers.push_back("memcache2:11211");
    servers.push_back("memcache3:11211");
    servers.push_back("memcache4:11211");

    // vytvoření klienta
    scfg.io_opts.timeouts.connect = 3000;
    scfg.io_opts.timeouts.write = 3000;
    scfg.io_opts.timeouts.read = 3000;
    mc::thread::client_t client(servers, scfg);

    // použití
    client.set("szn", "http://seznam.cz/");
    std::cout << client.get("szn").data << std::endl;
}

\endcode

Tento kód vám připraví k používání pool memcache serverů s konzistetním
hashováním a cachí persistetních spojení na každý memcache server. Tyto spojení
jsou udržovány otevření do první io chyby.  Pro komunikaci se bude používat
binární protokol, který memcache podporuje od verze 1.3.

\section public-api Veřejné ale i interní API

Celá knihovna se snaží nabídnout co největší flexibilitu, tak aby si každý, kdo
bude to potřebovat, mohl její chování co nejvíce upravit. Srdcem knihovny je
šablona třídy mc::client_t, která má ntři parametry.

\code
template <
    typename pool_t,
    typename server_proxies_t,
    typename impl
> class client_template_t;
\endcode

První parametr je třída zajišťující výběr správného memcache serveru ze všech
dostupných. Měla by mít takovéto rozhraní:

\code
struct some_pool_t {
public:
    using mod_pool_base_t::value_type;
    typedef some_pool_const_iterator const_iterator;
    const_iterator choose(const std::string &key) const;
};
\endcode

Kde metoda choose() vrací iterátor, který ukazuje na index do pole memcache
serverů, který vybrala pro tento klíč. Pokud dojde k chybě, a nebo je tento
memcache server označen jako mrtvý, pak se vrácený iterátor zkusí 


*/
